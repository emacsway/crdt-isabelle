\documentclass[professionalfonts,smallfonts]{beamer}

\usepackage[british]{babel}
\usepackage{microtype}

\usetheme{metropolis}

\author{Dominic Mulligan \\ Joint work with Victor Gomes, Martin Kleppmann, and Alastair Beresford}
\title{Verifying Conflict Free Replicated Datatypes}
\date{Cambridge-Imperial REMS Meeting, 2017}

\begin{document}

\begin{frame}
\maketitle
\end{frame}

\begin{frame}
\frametitle{Consistency models in distributed systems}
\onslide<1->{
\emph{Strong consistency} model impossible or costly to achieve}
\\[1.5ex]
\onslide<2->{
Must seek weaker consistency guarantees
\\[1.5ex]
Popular alternative is \emph{eventual consistency}}
\\[1.5ex]
\onslide<3->{
Informally:
\begin{enumerate}
\item
If no changes are made to some component of shared global state
\item
Eventually all replicas will converge to some consensus on value of that component
\end{enumerate}}
\end{frame}

\begin{frame}
\frametitle{Eventual consistency}
\onslide<1->{
Eventual consistency is very weak consistency model!}
\\[1.5ex]
\onslide<2->{
Model:
\begin{itemize}
\item
makes no guarantees in case where updates never cease,
\item
and does not constrain return value of intermediate reads
\end{itemize}}
\end{frame}

\begin{frame}
\frametitle{Trade-offs}
\onslide<1->{
Range of consistency models exists because of a tradeoff:
\begin{center}
Performance vs. guarantees offered by model
\end{center}}
\vspace{\baselineskip}
\onslide<2->{
Possible to find intermediate models:
\begin{itemize}
\item
Obtain stronger guarantees than those provided by eventual consistency
\item
Without inheriting the inherent costs of strong consistency
\end{itemize}}
\vspace{\baselineskip}
\onslide<3->{
One such consistency model is \emph{strong eventual consistency}}
\end{frame}

\begin{frame}
\frametitle{Strong eventual consistency}
\onslide<1->{
Strong eventual consistency (Shapiro, 2011) has:
\begin{itemize}
\item
Performance and fault-tolerance characteristics similar to eventual consistency
\item
Provides stronger guarantees
\end{itemize}}
\onslide<2->{
A system satisfying strong eventual consistency must satisfy:
\begin{itemize}
\item
Correct replicas that have received same updates have same state,
\item
Update delivered at a replica is eventually delivered to all replicas,
\item
All executions must terminate
\end{itemize}}
\onslide<3->{
First property (`convergence') most important}
\end{frame}

\begin{frame}
\frametitle{Conflict Free Replicated Datatypes (CRDTs)}
\onslide<1->{
Achieving consensus in SEC:
\begin{itemize}
\item
Typically requires conflict resolution policy
\item
Simple policies cause data loss, complex ones are error prone
\end{itemize}}
\onslide<2->{
Observation:
\begin{itemize}
\item
Some operations naturally commutative
\item
Operations can therefore be applied in any order
\item
Generalise this to other data structures and operations
\end{itemize}}
\onslide<3->{
CRDTs = replicated data types with commutative operations}
\end{frame}

\begin{frame}
\frametitle{Three families of CRDT}
\onslide<1->{
Three different types of CRDT are known:
\begin{itemize}
\item
Operation based CRDTs: construct operations so they are commutative
\item
State based CRDTs: broadcast entire state of replica when it changes
\item
Delta-CRDTs: broadcast changes to states, not entire states
\end{itemize}}
\onslide<2->{
We consider operation based CRDTs in this work}
\end{frame}

\begin{frame}
\frametitle{Why is verification necessary here?}
\onslide<1->{
\emph{Operational Transformation} is a closely related technique}
\\[1.5ex]
\onslide<2->{
Algorithms have claimed to satisfy $TP_2$ but later shown incorrect}
\\[1.5ex]
\onslide<3->{
Algorithms have been presented without any proof}
\\[1.5ex]
\onslide<4->{
In classic formulation of OT, later shown impossible to achieve $TP_2$}
\\[1.5ex]
\onslide<5->{
Hand-written proofs of convergence tend to be gigantic}
\\[1.5ex]
\onslide<6->{
Several wrong machine checked proofs presented (!)}
\\[1.5ex]
\onslide<7->{
Moral: reasoning about replicated data structures is hard}
\end{frame}

\begin{frame}
\frametitle{Diagnosing bugs in previous proofs}
\onslide<1->{
Relied on high-level axioms stated in terms of data structure, and operations on it}
\\[1.5ex]
\onslide<2->{
But reasoning about data structure is hard, and unintuitive!
\\[1.5ex]
Wrong axioms are therefore hard to spot
\\[1.5ex]
Need to think of all possible network behaviours to spot them!}
\\[1.5ex]
\onslide<3->{
Moral: need end-to-end verification to ensure correctness
\\[1.5ex]
Ensure required properties hold in all network executions}
\end{frame}

\begin{frame}
\frametitle{Our contributions: a framework for verifying CRDTs}
\onslide<1->{
We develop a stratified proof \emph{framework} for CRDTs}
\\[1.5ex]
\onslide<2->{
We have three different `components':
\begin{itemize}
\item
A network model,
\item
An abstract convergence theorem
\item
An implementation of a concrete CRDT
\end{itemize}}
\onslide<3->{
Piecing all three together gives a concrete convergence theorem for the CRDT
\\[1.5ex]
Two components are reusable}
\end{frame}

\begin{frame}
\frametitle{Our contributions: modelling the network}
\onslide<1->{
In one component, we:
\begin{itemize}
\item
Model a standard class of networks, axiomatically
\item
Our axioms are easy to defend
\item
Use standard broadcast/deliver event model for network
\item
Contents of messages are abstract
\end{itemize}}
\onslide<2->{
By working axiomatically:
\begin{itemize}
\item
Reason about all possible network behaviours
\item
Eliminate corner cases that may invalidate high-level proofs
\end{itemize}}
\end{frame}

\begin{frame}
\frametitle{Our contributions: abstract convergence}
\onslide<1->{
In another component, we:
\\[1.5ex]
Parameterise our work with a preorder on abstract `events' called \emph{happens before}}
\\[1.5ex]
\onslide<2->{
Parameterise by a method of lifting `events' to `state transformers'}
\\[1.5ex]
\onslide<3->{
For two lists of events $xs$ and $ys$, if we assume:
\begin{itemize}
\item
Concurrent events in both $xs$ and $ys$ commute
\item
All events in $xs$ and $ys$ respect the happens before relation
\end{itemize}}
\onslide<4->{
Then: applying the state transformers in both $xs$ and $ys$ to the same initial state gives the same final state}
\end{frame}

\begin{frame}
\frametitle{Our contributions}
In a final component, we:
\begin{itemize}
\item
Formalise the Replicated Growable Array (RGA) CRDT
\item
Show operations commute with themselves, and with each other, under assumptions
\item
Work in terms of insert/delete messages with concrete elements to insert into array
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Composing components}
\onslide<1->{
We compose:
\begin{itemize}
\item
Our network model has an associated concrete \emph{happens before} relation
\item
Given in terms of broadcast and deliver events
\item
This relation is a preorder
\end{itemize}}
\onslide<2->{
We can then replace the parameter in our abstract theorem with this relation}
\end{frame}

\begin{frame}
\frametitle{Composing components}
\onslide<1->{
As a corollary of abstract theorem, obtain a concrete convergence theorem for CRDT}
\\[1.5ex]
\onslide<2->{
Assuming two finite lists of deliver events, with insert/delete messages}
\\[1.5ex]
\onslide<3->{
Such that the messages delivered are the same (but not necessarily in same order)}
\\[1.5ex]
\onslide<4->{
Then applying these insert/delete operations to an initial state yields the same list}
\\[1.5ex]
\onslide<5->{
Convergence, from definition of strong eventual consistency}
\end{frame}

\begin{frame}
\frametitle{Conclusions}
\onslide<1->{
Distributed algorithms hard to verify
\\[1.5ex]
Many mistakes in previous proofs of distributed algorithms
\\[1.5ex]
Even those checked by machine!}
\\[1.5ex]
\onslide<2->{
Must use end-to-end verification for confidence}
\\[1.5ex]
\onslide<3->{
Developed a framework for end-to-end verification of CRDTs
\\[1.5ex]
Verified RGA CRDT implementation as an example}
\end{frame}

\end{document}
